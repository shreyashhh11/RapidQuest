const fs = require('fs').promises;
const path = require('path');
const pdfParse = require('pdf-parse');
const { marked } = require('marked');

class DocumentProcessor {
    constructor() {
        this.maxFileSize = 10 * 1024 * 1024; // 10MB
        this.allowedExtensions = ['.pdf', '.txt', '.md'];
    }

    async processFile(filePath, originalName) {
        try {
            const extension = path.extname(originalName).toLowerCase();
            
            if (!this.allowedExtensions.includes(extension)) {
                throw new Error(`Unsupported file type: ${extension}. Only PDF, TXT, and MD files are allowed.`);
            }

            const stats = await fs.stat(filePath);
            if (stats.size > this.maxFileSize) {
                throw new Error(`File too large. Maximum size is ${this.maxFileSize / (1024 * 1024)}MB.`);
            }

            let content = '';
            let metadata = {
                originalName,
                extension,
                size: stats.size,
                processedAt: new Date().toISOString()
            };

            switch (extension) {
                case '.pdf':
                    content = await this.processPDF(filePath);
                    break;
                case '.txt':
                    content = await this.processText(filePath);
                    break;
                case '.md':
                    content = await this.processMarkdown(filePath);
                    break;
                default:
                    throw new Error(`Unsupported file extension: ${extension}`);
            }

            // Add word and page count
            const wordCount = content.split(/\s+/).filter(word => word.length > 0).length;
            const pageCount = extension === '.pdf' ? await this.countPDFPages(filePath) : 1;
            
            metadata.wordCount = wordCount;
            metadata.pageCount = pageCount;

            return {
                content,
                metadata,
                embedding: null // Will be generated by search service
            };

        } catch (error) {
            throw new Error(`Failed to process file ${originalName}: ${error.message}`);
        }
    }

    async processPDF(filePath) {
        try {
            const dataBuffer = await fs.readFile(filePath);
            const data = await pdfParse(dataBuffer);
            return data.text || '';
        } catch (error) {
            throw new Error(`Failed to parse PDF: ${error.message}`);
        }
    }

    async processText(filePath) {
        try {
            return await fs.readFile(filePath, 'utf8');
        } catch (error) {
            throw new Error(`Failed to read text file: ${error.message}`);
        }
    }

    async processMarkdown(filePath) {
        try {
            const markdownContent = await fs.readFile(filePath, 'utf8');
            const html = marked(markdownContent);
            // Extract text from HTML
            return html.replace(/<[^>]*>/g, '').replace(/&[^;]+;/g, ' ');
        } catch (error) {
            throw new Error(`Failed to process markdown file: ${error.message}`);
        }
    }

    async countPDFPages(filePath) {
        try {
            const dataBuffer = await fs.readFile(filePath);
            const data = await pdfParse(dataBuffer);
            // PDF.js doesn't always provide accurate page count, so we'll estimate
            // Based on content length and common page lengths
            const textLength = data.text.length;
            const estimatedPages = Math.max(1, Math.ceil(textLength / 2000));
            return estimatedPages;
        } catch (error) {
            return 1; // Default to 1 page if we can't determine
        }
    }

    async cleanup(filePath) {
        try {
            await fs.unlink(filePath);
        } catch (error) {
            console.warn(`Failed to cleanup file ${filePath}:`, error.message);
        }
    }
}

module.exports = DocumentProcessor;